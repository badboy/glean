/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const UPLOAD_RESULT_RECOVERABLE: u32 = 1;
pub const UPLOAD_RESULT_UNRECOVERABLE: u32 = 2;
pub const UPLOAD_RESULT_HTTP_STATUS: u32 = 32768;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[doc = " `FfiStr<'a>` is a safe (`#[repr(transparent)]`) wrapper around a"]
#[doc = " nul-terminated `*const c_char` (e.g. a C string). Conceptually, it is"]
#[doc = " similar to [`std::ffi::CStr`], except that it may be used in the signatures"]
#[doc = " of extern \"C\" functions."]
#[doc = ""]
#[doc = " Functions accepting strings should use this instead of accepting a C string"]
#[doc = " directly. This allows us to write those functions using safe code without"]
#[doc = " allowing safe Rust to cause memory unsafety."]
#[doc = ""]
#[doc = " A single function for constructing these from Rust ([`FfiStr::from_raw`])"]
#[doc = " has been provided. Most of the time, this should not be necessary, and users"]
#[doc = " should accept `FfiStr` in the parameter list directly."]
#[doc = ""]
#[doc = " ## Caveats"]
#[doc = ""]
#[doc = " An effort has been made to make this struct hard to misuse, however it is"]
#[doc = " still possible, if the `'static` lifetime is manually specified in the"]
#[doc = " struct. E.g."]
#[doc = ""]
#[doc = " ```rust,no_run"]
#[doc = " # use ffi_support::FfiStr;"]
#[doc = " // NEVER DO THIS"]
#[doc = " #[no_mangle]"]
#[doc = " extern \"C\" fn never_do_this(s: FfiStr<'static>) {"]
#[doc = "     // save `s` somewhere, and access it after this"]
#[doc = "     // function returns."]
#[doc = " }"]
#[doc = " ```"]
#[doc = ""]
#[doc = " Instead, one of the following patterns should be used:"]
#[doc = ""]
#[doc = " ```"]
#[doc = " # use ffi_support::FfiStr;"]
#[doc = " #[no_mangle]"]
#[doc = " extern \"C\" fn valid_use_1(s: FfiStr<'_>) {"]
#[doc = "     // Use of `s` after this function returns is impossible"]
#[doc = " }"]
#[doc = " // Alternative:"]
#[doc = " #[no_mangle]"]
#[doc = " extern \"C\" fn valid_use_2(s: FfiStr) {"]
#[doc = "     // Use of `s` after this function returns is impossible"]
#[doc = " }"]
#[doc = " ```"]
pub type FfiStr = *const ::std::os::raw::c_char;
#[doc = " Configuration over FFI."]
#[doc = ""]
#[doc = " **CAUTION**: This must match _exactly_ the definition on the Kotlin side."]
#[doc = " If this side is changed, the Kotlin side need to be changed, too."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfiConfiguration {
    pub data_dir: FfiStr,
    pub package_name: FfiStr,
    pub language_binding_name: FfiStr,
    pub upload_enabled: u8,
    pub max_events: *const i32,
    pub delay_ping_lifetime_io: u8,
}
pub type RawStringArray = *const *const ::std::os::raw::c_char;
#[doc = " ByteBuffer is a struct that represents an array of bytes to be sent over the FFI boundaries."]
#[doc = " There are several cases when you might want to use this, but the primary one for us"]
#[doc = " is for returning protobuf-encoded data to Swift and Java. The type is currently rather"]
#[doc = " limited (implementing almost no functionality), however in the future it may be"]
#[doc = " more expanded."]
#[doc = ""]
#[doc = " ## Caveats"]
#[doc = ""]
#[doc = " Note that the order of the fields is `len` (an i32) then `data` (a `*mut u8`), getting"]
#[doc = " this wrong on the other side of the FFI will cause memory corruption and crashes."]
#[doc = " `i32` is used for the length instead of `u64` and `usize` because JNA has interop"]
#[doc = " issues with both these types."]
#[doc = ""]
#[doc = " ByteBuffer does not implement Drop. This is intentional. Memory passed into it will"]
#[doc = " be leaked if it is not explicitly destroyed by calling [`ByteBuffer::destroy`]. This"]
#[doc = " is because in the future, we may allow it's use for passing data into Rust code."]
#[doc = " ByteBuffer assuming ownership of the data would make this a problem."]
#[doc = ""]
#[doc = " ## Layout/fields"]
#[doc = ""]
#[doc = " This struct's field are not `pub` (mostly so that we can soundly implement `Send`, but also so"]
#[doc = " that we can verify Rust users are constructing them appropriately), the fields, their types, and"]
#[doc = " their order are *very much* a part of the public API of this type. Consumers on the other side"]
#[doc = " of the FFI will need to know its layout."]
#[doc = ""]
#[doc = " If this were a C struct, it would look like"]
#[doc = ""]
#[doc = " ```c,no_run"]
#[doc = " struct ByteBuffer {"]
#[doc = "     int64_t len;"]
#[doc = "     uint8_t *data; // note: nullable"]
#[doc = " };"]
#[doc = " ```"]
#[doc = ""]
#[doc = " In Rust, there are two fields, in this order: `len: i32`, and `data: *mut u8`."]
#[doc = ""]
#[doc = " ### Description of fields"]
#[doc = ""]
#[doc = " `data` is a pointer to an array of `len` bytes. Not that data can be a null pointer and therefore"]
#[doc = " should be checked."]
#[doc = ""]
#[doc = " The bytes array is allocated on the heap and must be freed on it as well. Critically, if there"]
#[doc = " are multiple rust packages using being used in the same application, it *must be freed on the"]
#[doc = " same heap that allocated it*, or you will corrupt both heaps."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ByteBuffer {
    pub len: i32,
    pub data: *mut u8,
}
#[repr(C)]
pub struct FfiPingUploadTask_Upload_Body {
    pub tag: FfiPingUploadTask_Tag,
    pub document_id: *mut ::std::os::raw::c_char,
    pub path: *mut ::std::os::raw::c_char,
    pub body: ByteBuffer,
    pub headers: *mut ::std::os::raw::c_char,
}
#[repr(C)]
pub struct FfiPingUploadTask {
    pub tag: __BindgenUnionField<FfiPingUploadTask_Tag>,
    pub upload: __BindgenUnionField<FfiPingUploadTask_Upload_Body>,
    pub __bindgen_anon_1: __BindgenUnionField<FfiPingUploadTask__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
pub struct FfiPingUploadTask__bindgen_ty_1 {
    pub wait_tag: FfiPingUploadTask_Tag,
    pub wait: u64,
}
pub type RawInt64Array = *const i64;
pub type RawIntArray = *const i32;
#[doc = " Identifier for a running timer."]
pub type TimerId = u64;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
extern crate libloading;
pub struct GleanSys {
    __library: ::libloading::Library,
    pub glean_enable_logging: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub glean_enable_logging_to_fd: Result<unsafe extern "C" fn(fd: u64), ::libloading::Error>,
    pub glean_initialize:
        Result<unsafe extern "C" fn(cfg: *const FfiConfiguration) -> u8, ::libloading::Error>,
    pub glean_on_ready_to_submit_pings: Result<unsafe extern "C" fn() -> u8, ::libloading::Error>,
    pub glean_is_upload_enabled: Result<unsafe extern "C" fn() -> u8, ::libloading::Error>,
    pub glean_set_upload_enabled: Result<unsafe extern "C" fn(flag: u8), ::libloading::Error>,
    pub glean_submit_ping_by_name:
        Result<unsafe extern "C" fn(ping_name: FfiStr, reason: FfiStr) -> u8, ::libloading::Error>,
    pub glean_ping_collect: Result<
        unsafe extern "C" fn(ping_type_handle: u64, reason: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_set_experiment_active: Result<
        unsafe extern "C" fn(
            experiment_id: FfiStr,
            branch: FfiStr,
            extra_keys: RawStringArray,
            extra_values: RawStringArray,
            extra_len: i32,
        ),
        ::libloading::Error,
    >,
    pub glean_set_experiment_inactive:
        Result<unsafe extern "C" fn(experiment_id: FfiStr), ::libloading::Error>,
    pub glean_experiment_test_is_active:
        Result<unsafe extern "C" fn(experiment_id: FfiStr) -> u8, ::libloading::Error>,
    pub glean_experiment_test_get_data: Result<
        unsafe extern "C" fn(experiment_id: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_clear_application_lifetime_metrics:
        Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub glean_flush_rlb_dispatcher: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub glean_set_dirty_flag: Result<unsafe extern "C" fn(flag: u8), ::libloading::Error>,
    pub glean_is_dirty_flag_set: Result<unsafe extern "C" fn() -> u8, ::libloading::Error>,
    pub glean_test_clear_all_stores: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub glean_destroy_glean: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub glean_is_first_run: Result<unsafe extern "C" fn() -> u8, ::libloading::Error>,
    pub glean_get_upload_task:
        Result<unsafe extern "C" fn(result: *mut FfiPingUploadTask), ::libloading::Error>,
    pub glean_process_ping_upload_response: Result<
        unsafe extern "C" fn(task: *mut FfiPingUploadTask, status: u32),
        ::libloading::Error,
    >,
    pub glean_initialize_for_subprocess:
        Result<unsafe extern "C" fn(cfg: *const FfiConfiguration) -> u8, ::libloading::Error>,
    pub glean_set_debug_view_tag:
        Result<unsafe extern "C" fn(tag: FfiStr) -> u8, ::libloading::Error>,
    pub glean_set_log_pings: Result<unsafe extern "C" fn(value: u8), ::libloading::Error>,
    pub glean_set_source_tags: Result<
        unsafe extern "C" fn(raw_tags: RawStringArray, tags_count: i32) -> u8,
        ::libloading::Error,
    >,
    pub glean_str_free:
        Result<unsafe extern "C" fn(s: *mut ::std::os::raw::c_char), ::libloading::Error>,
    pub glean_destroy_boolean_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_boolean_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_boolean_set:
        Result<unsafe extern "C" fn(metric_id: u64, value: u8), ::libloading::Error>,
    pub glean_boolean_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_boolean_test_get_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_destroy_counter_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_counter_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_counter_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_counter_add:
        Result<unsafe extern "C" fn(metric_id: u64, amount: i32), ::libloading::Error>,
    pub glean_counter_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_counter_test_get_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_destroy_custom_distribution_metric:
        Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_custom_distribution_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            range_min: u64,
            range_max: u64,
            bucket_count: u64,
            histogram_type: i32,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_custom_distribution_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_custom_distribution_accumulate_samples: Result<
        unsafe extern "C" fn(metric_id: u64, raw_samples: RawInt64Array, num_samples: i32),
        ::libloading::Error,
    >,
    pub glean_custom_distribution_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_custom_distribution_test_get_value_as_json_string: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_destroy_datetime_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_datetime_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            time_unit: TimeUnit,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_datetime_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_datetime_set: Result<
        unsafe extern "C" fn(
            metric_id: u64,
            year: i32,
            month: u32,
            day: u32,
            hour: u32,
            minute: u32,
            second: u32,
            nano: i64,
            offset_seconds: i32,
        ),
        ::libloading::Error,
    >,
    pub glean_datetime_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_datetime_test_get_value_as_string: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_destroy_event_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_event_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_new_event_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            extra_keys: RawStringArray,
            extra_keys_len: i32,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_event_record: Result<
        unsafe extern "C" fn(
            metric_id: u64,
            timestamp: u64,
            extra_keys: RawIntArray,
            extra_values: RawStringArray,
            extra_len: i32,
        ),
        ::libloading::Error,
    >,
    pub glean_event_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_event_test_get_value_as_json_string: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_destroy_jwe_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_jwe_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_jwe_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_jwe_set_with_compact_representation:
        Result<unsafe extern "C" fn(metric_id: u64, value: FfiStr), ::libloading::Error>,
    pub glean_jwe_set: Result<
        unsafe extern "C" fn(
            metric_id: u64,
            header: FfiStr,
            key: FfiStr,
            init_vector: FfiStr,
            cipher_text: FfiStr,
            auth_tag: FfiStr,
        ),
        ::libloading::Error,
    >,
    pub glean_jwe_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_jwe_test_get_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_jwe_test_get_value_as_json_string: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_destroy_labeled_counter_metric:
        Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_labeled_counter_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            labels: RawStringArray,
            label_count: i32,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_labeled_counter_metric_get:
        Result<unsafe extern "C" fn(handle: u64, label: FfiStr) -> u64, ::libloading::Error>,
    pub glean_labeled_counter_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_destroy_labeled_boolean_metric:
        Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_labeled_boolean_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            labels: RawStringArray,
            label_count: i32,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_labeled_boolean_metric_get:
        Result<unsafe extern "C" fn(handle: u64, label: FfiStr) -> u64, ::libloading::Error>,
    pub glean_labeled_boolean_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_destroy_labeled_string_metric:
        Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_labeled_string_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            labels: RawStringArray,
            label_count: i32,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_labeled_string_metric_get:
        Result<unsafe extern "C" fn(handle: u64, label: FfiStr) -> u64, ::libloading::Error>,
    pub glean_labeled_string_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_destroy_memory_distribution_metric:
        Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_memory_distribution_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            memory_unit: MemoryUnit,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_memory_distribution_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_memory_distribution_accumulate:
        Result<unsafe extern "C" fn(metric_id: u64, sample: u64), ::libloading::Error>,
    pub glean_memory_distribution_accumulate_samples: Result<
        unsafe extern "C" fn(metric_id: u64, raw_samples: RawInt64Array, num_samples: i32),
        ::libloading::Error,
    >,
    pub glean_memory_distribution_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_memory_distribution_test_get_value_as_json_string: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_destroy_ping_type: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_ping_type: Result<
        unsafe extern "C" fn(
            ping_name: FfiStr,
            include_client_id: u8,
            send_if_empty: u8,
            reason_codes: RawStringArray,
            reason_codes_len: i32,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_test_has_ping_type:
        Result<unsafe extern "C" fn(ping_name: FfiStr) -> u8, ::libloading::Error>,
    pub glean_register_ping_type:
        Result<unsafe extern "C" fn(ping_type_handle: u64), ::libloading::Error>,
    pub glean_destroy_quantity_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_quantity_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_quantity_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_quantity_set:
        Result<unsafe extern "C" fn(metric_id: u64, value: i64), ::libloading::Error>,
    pub glean_quantity_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_quantity_test_get_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> i64,
        ::libloading::Error,
    >,
    pub glean_destroy_string_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_string_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_string_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_string_set:
        Result<unsafe extern "C" fn(metric_id: u64, value: FfiStr), ::libloading::Error>,
    pub glean_string_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_string_test_get_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_destroy_string_list_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_string_list_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_string_list_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_string_list_add:
        Result<unsafe extern "C" fn(metric_id: u64, value: FfiStr), ::libloading::Error>,
    pub glean_string_list_set: Result<
        unsafe extern "C" fn(metric_id: u64, values: RawStringArray, values_len: i32),
        ::libloading::Error,
    >,
    pub glean_string_list_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_string_list_test_get_value_as_json_string: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_destroy_timespan_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_timespan_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            time_unit: i32,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_timespan_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_timespan_set_start:
        Result<unsafe extern "C" fn(metric_id: u64, start_time: u64), ::libloading::Error>,
    pub glean_timespan_set_stop:
        Result<unsafe extern "C" fn(metric_id: u64, stop_time: u64), ::libloading::Error>,
    pub glean_timespan_cancel: Result<unsafe extern "C" fn(metric_id: u64), ::libloading::Error>,
    pub glean_timespan_set_raw_nanos:
        Result<unsafe extern "C" fn(metric_id: u64, elapsed_nanos: u64), ::libloading::Error>,
    pub glean_timespan_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_timespan_test_get_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u64,
        ::libloading::Error,
    >,
    pub glean_destroy_timing_distribution_metric:
        Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_timing_distribution_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
            time_unit: TimeUnit,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_timing_distribution_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_timing_distribution_set_start: Result<
        unsafe extern "C" fn(metric_id: u64, start_time: u64) -> TimerId,
        ::libloading::Error,
    >,
    pub glean_timing_distribution_set_stop_and_accumulate: Result<
        unsafe extern "C" fn(metric_id: u64, timer_id: TimerId, stop_time: u64),
        ::libloading::Error,
    >,
    pub glean_timing_distribution_cancel:
        Result<unsafe extern "C" fn(metric_id: u64, timer_id: TimerId), ::libloading::Error>,
    pub glean_timing_distribution_accumulate_samples: Result<
        unsafe extern "C" fn(metric_id: u64, raw_samples: RawInt64Array, num_samples: i32),
        ::libloading::Error,
    >,
    pub glean_timing_distribution_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_timing_distribution_test_get_value_as_json_string: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub glean_destroy_uuid_metric: Result<unsafe extern "C" fn(v: u64), ::libloading::Error>,
    pub glean_new_uuid_metric: Result<
        unsafe extern "C" fn(
            category: FfiStr,
            name: FfiStr,
            send_in_pings: RawStringArray,
            send_in_pings_len: i32,
            lifetime: Lifetime,
            disabled: u8,
        ) -> u64,
        ::libloading::Error,
    >,
    pub glean_uuid_test_get_num_recorded_errors: Result<
        unsafe extern "C" fn(metric_id: u64, error_type: i32, storage_name: FfiStr) -> i32,
        ::libloading::Error,
    >,
    pub glean_uuid_set:
        Result<unsafe extern "C" fn(metric_id: u64, value: FfiStr), ::libloading::Error>,
    pub glean_uuid_test_has_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> u8,
        ::libloading::Error,
    >,
    pub glean_uuid_test_get_value: Result<
        unsafe extern "C" fn(metric_id: u64, storage_name: FfiStr) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
}
impl GleanSys {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let __library = ::libloading::Library::new(path)?;
        let glean_enable_logging = __library
            .get("glean_enable_logging".as_bytes())
            .map(|sym| *sym);
        let glean_enable_logging_to_fd = __library
            .get("glean_enable_logging_to_fd".as_bytes())
            .map(|sym| *sym);
        let glean_initialize = __library.get("glean_initialize".as_bytes()).map(|sym| *sym);
        let glean_on_ready_to_submit_pings = __library
            .get("glean_on_ready_to_submit_pings".as_bytes())
            .map(|sym| *sym);
        let glean_is_upload_enabled = __library
            .get("glean_is_upload_enabled".as_bytes())
            .map(|sym| *sym);
        let glean_set_upload_enabled = __library
            .get("glean_set_upload_enabled".as_bytes())
            .map(|sym| *sym);
        let glean_submit_ping_by_name = __library
            .get("glean_submit_ping_by_name".as_bytes())
            .map(|sym| *sym);
        let glean_ping_collect = __library
            .get("glean_ping_collect".as_bytes())
            .map(|sym| *sym);
        let glean_set_experiment_active = __library
            .get("glean_set_experiment_active".as_bytes())
            .map(|sym| *sym);
        let glean_set_experiment_inactive = __library
            .get("glean_set_experiment_inactive".as_bytes())
            .map(|sym| *sym);
        let glean_experiment_test_is_active = __library
            .get("glean_experiment_test_is_active".as_bytes())
            .map(|sym| *sym);
        let glean_experiment_test_get_data = __library
            .get("glean_experiment_test_get_data".as_bytes())
            .map(|sym| *sym);
        let glean_clear_application_lifetime_metrics = __library
            .get("glean_clear_application_lifetime_metrics".as_bytes())
            .map(|sym| *sym);
        let glean_flush_rlb_dispatcher = __library
            .get("glean_flush_rlb_dispatcher".as_bytes())
            .map(|sym| *sym);
        let glean_set_dirty_flag = __library
            .get("glean_set_dirty_flag".as_bytes())
            .map(|sym| *sym);
        let glean_is_dirty_flag_set = __library
            .get("glean_is_dirty_flag_set".as_bytes())
            .map(|sym| *sym);
        let glean_test_clear_all_stores = __library
            .get("glean_test_clear_all_stores".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_glean = __library
            .get("glean_destroy_glean".as_bytes())
            .map(|sym| *sym);
        let glean_is_first_run = __library
            .get("glean_is_first_run".as_bytes())
            .map(|sym| *sym);
        let glean_get_upload_task = __library
            .get("glean_get_upload_task".as_bytes())
            .map(|sym| *sym);
        let glean_process_ping_upload_response = __library
            .get("glean_process_ping_upload_response".as_bytes())
            .map(|sym| *sym);
        let glean_initialize_for_subprocess = __library
            .get("glean_initialize_for_subprocess".as_bytes())
            .map(|sym| *sym);
        let glean_set_debug_view_tag = __library
            .get("glean_set_debug_view_tag".as_bytes())
            .map(|sym| *sym);
        let glean_set_log_pings = __library
            .get("glean_set_log_pings".as_bytes())
            .map(|sym| *sym);
        let glean_set_source_tags = __library
            .get("glean_set_source_tags".as_bytes())
            .map(|sym| *sym);
        let glean_str_free = __library.get("glean_str_free".as_bytes()).map(|sym| *sym);
        let glean_destroy_boolean_metric = __library
            .get("glean_destroy_boolean_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_boolean_metric = __library
            .get("glean_new_boolean_metric".as_bytes())
            .map(|sym| *sym);
        let glean_boolean_set = __library
            .get("glean_boolean_set".as_bytes())
            .map(|sym| *sym);
        let glean_boolean_test_has_value = __library
            .get("glean_boolean_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_boolean_test_get_value = __library
            .get("glean_boolean_test_get_value".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_counter_metric = __library
            .get("glean_destroy_counter_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_counter_metric = __library
            .get("glean_new_counter_metric".as_bytes())
            .map(|sym| *sym);
        let glean_counter_test_get_num_recorded_errors = __library
            .get("glean_counter_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_counter_add = __library
            .get("glean_counter_add".as_bytes())
            .map(|sym| *sym);
        let glean_counter_test_has_value = __library
            .get("glean_counter_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_counter_test_get_value = __library
            .get("glean_counter_test_get_value".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_custom_distribution_metric = __library
            .get("glean_destroy_custom_distribution_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_custom_distribution_metric = __library
            .get("glean_new_custom_distribution_metric".as_bytes())
            .map(|sym| *sym);
        let glean_custom_distribution_test_get_num_recorded_errors = __library
            .get("glean_custom_distribution_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_custom_distribution_accumulate_samples = __library
            .get("glean_custom_distribution_accumulate_samples".as_bytes())
            .map(|sym| *sym);
        let glean_custom_distribution_test_has_value = __library
            .get("glean_custom_distribution_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_custom_distribution_test_get_value_as_json_string = __library
            .get("glean_custom_distribution_test_get_value_as_json_string".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_datetime_metric = __library
            .get("glean_destroy_datetime_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_datetime_metric = __library
            .get("glean_new_datetime_metric".as_bytes())
            .map(|sym| *sym);
        let glean_datetime_test_get_num_recorded_errors = __library
            .get("glean_datetime_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_datetime_set = __library
            .get("glean_datetime_set".as_bytes())
            .map(|sym| *sym);
        let glean_datetime_test_has_value = __library
            .get("glean_datetime_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_datetime_test_get_value_as_string = __library
            .get("glean_datetime_test_get_value_as_string".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_event_metric = __library
            .get("glean_destroy_event_metric".as_bytes())
            .map(|sym| *sym);
        let glean_event_test_get_num_recorded_errors = __library
            .get("glean_event_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_new_event_metric = __library
            .get("glean_new_event_metric".as_bytes())
            .map(|sym| *sym);
        let glean_event_record = __library
            .get("glean_event_record".as_bytes())
            .map(|sym| *sym);
        let glean_event_test_has_value = __library
            .get("glean_event_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_event_test_get_value_as_json_string = __library
            .get("glean_event_test_get_value_as_json_string".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_jwe_metric = __library
            .get("glean_destroy_jwe_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_jwe_metric = __library
            .get("glean_new_jwe_metric".as_bytes())
            .map(|sym| *sym);
        let glean_jwe_test_get_num_recorded_errors = __library
            .get("glean_jwe_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_jwe_set_with_compact_representation = __library
            .get("glean_jwe_set_with_compact_representation".as_bytes())
            .map(|sym| *sym);
        let glean_jwe_set = __library.get("glean_jwe_set".as_bytes()).map(|sym| *sym);
        let glean_jwe_test_has_value = __library
            .get("glean_jwe_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_jwe_test_get_value = __library
            .get("glean_jwe_test_get_value".as_bytes())
            .map(|sym| *sym);
        let glean_jwe_test_get_value_as_json_string = __library
            .get("glean_jwe_test_get_value_as_json_string".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_labeled_counter_metric = __library
            .get("glean_destroy_labeled_counter_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_labeled_counter_metric = __library
            .get("glean_new_labeled_counter_metric".as_bytes())
            .map(|sym| *sym);
        let glean_labeled_counter_metric_get = __library
            .get("glean_labeled_counter_metric_get".as_bytes())
            .map(|sym| *sym);
        let glean_labeled_counter_test_get_num_recorded_errors = __library
            .get("glean_labeled_counter_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_labeled_boolean_metric = __library
            .get("glean_destroy_labeled_boolean_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_labeled_boolean_metric = __library
            .get("glean_new_labeled_boolean_metric".as_bytes())
            .map(|sym| *sym);
        let glean_labeled_boolean_metric_get = __library
            .get("glean_labeled_boolean_metric_get".as_bytes())
            .map(|sym| *sym);
        let glean_labeled_boolean_test_get_num_recorded_errors = __library
            .get("glean_labeled_boolean_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_labeled_string_metric = __library
            .get("glean_destroy_labeled_string_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_labeled_string_metric = __library
            .get("glean_new_labeled_string_metric".as_bytes())
            .map(|sym| *sym);
        let glean_labeled_string_metric_get = __library
            .get("glean_labeled_string_metric_get".as_bytes())
            .map(|sym| *sym);
        let glean_labeled_string_test_get_num_recorded_errors = __library
            .get("glean_labeled_string_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_memory_distribution_metric = __library
            .get("glean_destroy_memory_distribution_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_memory_distribution_metric = __library
            .get("glean_new_memory_distribution_metric".as_bytes())
            .map(|sym| *sym);
        let glean_memory_distribution_test_get_num_recorded_errors = __library
            .get("glean_memory_distribution_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_memory_distribution_accumulate = __library
            .get("glean_memory_distribution_accumulate".as_bytes())
            .map(|sym| *sym);
        let glean_memory_distribution_accumulate_samples = __library
            .get("glean_memory_distribution_accumulate_samples".as_bytes())
            .map(|sym| *sym);
        let glean_memory_distribution_test_has_value = __library
            .get("glean_memory_distribution_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_memory_distribution_test_get_value_as_json_string = __library
            .get("glean_memory_distribution_test_get_value_as_json_string".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_ping_type = __library
            .get("glean_destroy_ping_type".as_bytes())
            .map(|sym| *sym);
        let glean_new_ping_type = __library
            .get("glean_new_ping_type".as_bytes())
            .map(|sym| *sym);
        let glean_test_has_ping_type = __library
            .get("glean_test_has_ping_type".as_bytes())
            .map(|sym| *sym);
        let glean_register_ping_type = __library
            .get("glean_register_ping_type".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_quantity_metric = __library
            .get("glean_destroy_quantity_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_quantity_metric = __library
            .get("glean_new_quantity_metric".as_bytes())
            .map(|sym| *sym);
        let glean_quantity_test_get_num_recorded_errors = __library
            .get("glean_quantity_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_quantity_set = __library
            .get("glean_quantity_set".as_bytes())
            .map(|sym| *sym);
        let glean_quantity_test_has_value = __library
            .get("glean_quantity_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_quantity_test_get_value = __library
            .get("glean_quantity_test_get_value".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_string_metric = __library
            .get("glean_destroy_string_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_string_metric = __library
            .get("glean_new_string_metric".as_bytes())
            .map(|sym| *sym);
        let glean_string_test_get_num_recorded_errors = __library
            .get("glean_string_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_string_set = __library.get("glean_string_set".as_bytes()).map(|sym| *sym);
        let glean_string_test_has_value = __library
            .get("glean_string_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_string_test_get_value = __library
            .get("glean_string_test_get_value".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_string_list_metric = __library
            .get("glean_destroy_string_list_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_string_list_metric = __library
            .get("glean_new_string_list_metric".as_bytes())
            .map(|sym| *sym);
        let glean_string_list_test_get_num_recorded_errors = __library
            .get("glean_string_list_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_string_list_add = __library
            .get("glean_string_list_add".as_bytes())
            .map(|sym| *sym);
        let glean_string_list_set = __library
            .get("glean_string_list_set".as_bytes())
            .map(|sym| *sym);
        let glean_string_list_test_has_value = __library
            .get("glean_string_list_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_string_list_test_get_value_as_json_string = __library
            .get("glean_string_list_test_get_value_as_json_string".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_timespan_metric = __library
            .get("glean_destroy_timespan_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_timespan_metric = __library
            .get("glean_new_timespan_metric".as_bytes())
            .map(|sym| *sym);
        let glean_timespan_test_get_num_recorded_errors = __library
            .get("glean_timespan_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_timespan_set_start = __library
            .get("glean_timespan_set_start".as_bytes())
            .map(|sym| *sym);
        let glean_timespan_set_stop = __library
            .get("glean_timespan_set_stop".as_bytes())
            .map(|sym| *sym);
        let glean_timespan_cancel = __library
            .get("glean_timespan_cancel".as_bytes())
            .map(|sym| *sym);
        let glean_timespan_set_raw_nanos = __library
            .get("glean_timespan_set_raw_nanos".as_bytes())
            .map(|sym| *sym);
        let glean_timespan_test_has_value = __library
            .get("glean_timespan_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_timespan_test_get_value = __library
            .get("glean_timespan_test_get_value".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_timing_distribution_metric = __library
            .get("glean_destroy_timing_distribution_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_timing_distribution_metric = __library
            .get("glean_new_timing_distribution_metric".as_bytes())
            .map(|sym| *sym);
        let glean_timing_distribution_test_get_num_recorded_errors = __library
            .get("glean_timing_distribution_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_timing_distribution_set_start = __library
            .get("glean_timing_distribution_set_start".as_bytes())
            .map(|sym| *sym);
        let glean_timing_distribution_set_stop_and_accumulate = __library
            .get("glean_timing_distribution_set_stop_and_accumulate".as_bytes())
            .map(|sym| *sym);
        let glean_timing_distribution_cancel = __library
            .get("glean_timing_distribution_cancel".as_bytes())
            .map(|sym| *sym);
        let glean_timing_distribution_accumulate_samples = __library
            .get("glean_timing_distribution_accumulate_samples".as_bytes())
            .map(|sym| *sym);
        let glean_timing_distribution_test_has_value = __library
            .get("glean_timing_distribution_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_timing_distribution_test_get_value_as_json_string = __library
            .get("glean_timing_distribution_test_get_value_as_json_string".as_bytes())
            .map(|sym| *sym);
        let glean_destroy_uuid_metric = __library
            .get("glean_destroy_uuid_metric".as_bytes())
            .map(|sym| *sym);
        let glean_new_uuid_metric = __library
            .get("glean_new_uuid_metric".as_bytes())
            .map(|sym| *sym);
        let glean_uuid_test_get_num_recorded_errors = __library
            .get("glean_uuid_test_get_num_recorded_errors".as_bytes())
            .map(|sym| *sym);
        let glean_uuid_set = __library.get("glean_uuid_set".as_bytes()).map(|sym| *sym);
        let glean_uuid_test_has_value = __library
            .get("glean_uuid_test_has_value".as_bytes())
            .map(|sym| *sym);
        let glean_uuid_test_get_value = __library
            .get("glean_uuid_test_get_value".as_bytes())
            .map(|sym| *sym);
        Ok(GleanSys {
            __library,
            glean_enable_logging,
            glean_enable_logging_to_fd,
            glean_initialize,
            glean_on_ready_to_submit_pings,
            glean_is_upload_enabled,
            glean_set_upload_enabled,
            glean_submit_ping_by_name,
            glean_ping_collect,
            glean_set_experiment_active,
            glean_set_experiment_inactive,
            glean_experiment_test_is_active,
            glean_experiment_test_get_data,
            glean_clear_application_lifetime_metrics,
            glean_flush_rlb_dispatcher,
            glean_set_dirty_flag,
            glean_is_dirty_flag_set,
            glean_test_clear_all_stores,
            glean_destroy_glean,
            glean_is_first_run,
            glean_get_upload_task,
            glean_process_ping_upload_response,
            glean_initialize_for_subprocess,
            glean_set_debug_view_tag,
            glean_set_log_pings,
            glean_set_source_tags,
            glean_str_free,
            glean_destroy_boolean_metric,
            glean_new_boolean_metric,
            glean_boolean_set,
            glean_boolean_test_has_value,
            glean_boolean_test_get_value,
            glean_destroy_counter_metric,
            glean_new_counter_metric,
            glean_counter_test_get_num_recorded_errors,
            glean_counter_add,
            glean_counter_test_has_value,
            glean_counter_test_get_value,
            glean_destroy_custom_distribution_metric,
            glean_new_custom_distribution_metric,
            glean_custom_distribution_test_get_num_recorded_errors,
            glean_custom_distribution_accumulate_samples,
            glean_custom_distribution_test_has_value,
            glean_custom_distribution_test_get_value_as_json_string,
            glean_destroy_datetime_metric,
            glean_new_datetime_metric,
            glean_datetime_test_get_num_recorded_errors,
            glean_datetime_set,
            glean_datetime_test_has_value,
            glean_datetime_test_get_value_as_string,
            glean_destroy_event_metric,
            glean_event_test_get_num_recorded_errors,
            glean_new_event_metric,
            glean_event_record,
            glean_event_test_has_value,
            glean_event_test_get_value_as_json_string,
            glean_destroy_jwe_metric,
            glean_new_jwe_metric,
            glean_jwe_test_get_num_recorded_errors,
            glean_jwe_set_with_compact_representation,
            glean_jwe_set,
            glean_jwe_test_has_value,
            glean_jwe_test_get_value,
            glean_jwe_test_get_value_as_json_string,
            glean_destroy_labeled_counter_metric,
            glean_new_labeled_counter_metric,
            glean_labeled_counter_metric_get,
            glean_labeled_counter_test_get_num_recorded_errors,
            glean_destroy_labeled_boolean_metric,
            glean_new_labeled_boolean_metric,
            glean_labeled_boolean_metric_get,
            glean_labeled_boolean_test_get_num_recorded_errors,
            glean_destroy_labeled_string_metric,
            glean_new_labeled_string_metric,
            glean_labeled_string_metric_get,
            glean_labeled_string_test_get_num_recorded_errors,
            glean_destroy_memory_distribution_metric,
            glean_new_memory_distribution_metric,
            glean_memory_distribution_test_get_num_recorded_errors,
            glean_memory_distribution_accumulate,
            glean_memory_distribution_accumulate_samples,
            glean_memory_distribution_test_has_value,
            glean_memory_distribution_test_get_value_as_json_string,
            glean_destroy_ping_type,
            glean_new_ping_type,
            glean_test_has_ping_type,
            glean_register_ping_type,
            glean_destroy_quantity_metric,
            glean_new_quantity_metric,
            glean_quantity_test_get_num_recorded_errors,
            glean_quantity_set,
            glean_quantity_test_has_value,
            glean_quantity_test_get_value,
            glean_destroy_string_metric,
            glean_new_string_metric,
            glean_string_test_get_num_recorded_errors,
            glean_string_set,
            glean_string_test_has_value,
            glean_string_test_get_value,
            glean_destroy_string_list_metric,
            glean_new_string_list_metric,
            glean_string_list_test_get_num_recorded_errors,
            glean_string_list_add,
            glean_string_list_set,
            glean_string_list_test_has_value,
            glean_string_list_test_get_value_as_json_string,
            glean_destroy_timespan_metric,
            glean_new_timespan_metric,
            glean_timespan_test_get_num_recorded_errors,
            glean_timespan_set_start,
            glean_timespan_set_stop,
            glean_timespan_cancel,
            glean_timespan_set_raw_nanos,
            glean_timespan_test_has_value,
            glean_timespan_test_get_value,
            glean_destroy_timing_distribution_metric,
            glean_new_timing_distribution_metric,
            glean_timing_distribution_test_get_num_recorded_errors,
            glean_timing_distribution_set_start,
            glean_timing_distribution_set_stop_and_accumulate,
            glean_timing_distribution_cancel,
            glean_timing_distribution_accumulate_samples,
            glean_timing_distribution_test_has_value,
            glean_timing_distribution_test_get_value_as_json_string,
            glean_destroy_uuid_metric,
            glean_new_uuid_metric,
            glean_uuid_test_get_num_recorded_errors,
            glean_uuid_set,
            glean_uuid_test_has_value,
            glean_uuid_test_get_value,
        })
    }
    pub unsafe fn glean_enable_logging(&self) -> () {
        let sym = self
            .glean_enable_logging
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_enable_logging_to_fd(&self, fd: u64) -> () {
        let sym = self
            .glean_enable_logging_to_fd
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(fd)
    }
    pub unsafe fn glean_initialize(&self, cfg: *const FfiConfiguration) -> u8 {
        let sym = self
            .glean_initialize
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(cfg)
    }
    pub unsafe fn glean_on_ready_to_submit_pings(&self) -> u8 {
        let sym = self
            .glean_on_ready_to_submit_pings
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_is_upload_enabled(&self) -> u8 {
        let sym = self
            .glean_is_upload_enabled
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_set_upload_enabled(&self, flag: u8) -> () {
        let sym = self
            .glean_set_upload_enabled
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(flag)
    }
    pub unsafe fn glean_submit_ping_by_name(&self, ping_name: FfiStr, reason: FfiStr) -> u8 {
        let sym = self
            .glean_submit_ping_by_name
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(ping_name, reason)
    }
    pub unsafe fn glean_ping_collect(
        &self,
        ping_type_handle: u64,
        reason: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_ping_collect
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(ping_type_handle, reason)
    }
    pub unsafe fn glean_set_experiment_active(
        &self,
        experiment_id: FfiStr,
        branch: FfiStr,
        extra_keys: RawStringArray,
        extra_values: RawStringArray,
        extra_len: i32,
    ) -> () {
        let sym = self
            .glean_set_experiment_active
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(experiment_id, branch, extra_keys, extra_values, extra_len)
    }
    pub unsafe fn glean_set_experiment_inactive(&self, experiment_id: FfiStr) -> () {
        let sym = self
            .glean_set_experiment_inactive
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(experiment_id)
    }
    pub unsafe fn glean_experiment_test_is_active(&self, experiment_id: FfiStr) -> u8 {
        let sym = self
            .glean_experiment_test_is_active
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(experiment_id)
    }
    pub unsafe fn glean_experiment_test_get_data(
        &self,
        experiment_id: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_experiment_test_get_data
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(experiment_id)
    }
    pub unsafe fn glean_clear_application_lifetime_metrics(&self) -> () {
        let sym = self
            .glean_clear_application_lifetime_metrics
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_flush_rlb_dispatcher(&self) -> () {
        let sym = self
            .glean_flush_rlb_dispatcher
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_set_dirty_flag(&self, flag: u8) -> () {
        let sym = self
            .glean_set_dirty_flag
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(flag)
    }
    pub unsafe fn glean_is_dirty_flag_set(&self) -> u8 {
        let sym = self
            .glean_is_dirty_flag_set
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_test_clear_all_stores(&self) -> () {
        let sym = self
            .glean_test_clear_all_stores
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_destroy_glean(&self) -> () {
        let sym = self
            .glean_destroy_glean
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_is_first_run(&self) -> u8 {
        let sym = self
            .glean_is_first_run
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn glean_get_upload_task(&self, result: *mut FfiPingUploadTask) -> () {
        let sym = self
            .glean_get_upload_task
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(result)
    }
    pub unsafe fn glean_process_ping_upload_response(
        &self,
        task: *mut FfiPingUploadTask,
        status: u32,
    ) -> () {
        let sym = self
            .glean_process_ping_upload_response
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(task, status)
    }
    pub unsafe fn glean_initialize_for_subprocess(&self, cfg: *const FfiConfiguration) -> u8 {
        let sym = self
            .glean_initialize_for_subprocess
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(cfg)
    }
    pub unsafe fn glean_set_debug_view_tag(&self, tag: FfiStr) -> u8 {
        let sym = self
            .glean_set_debug_view_tag
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(tag)
    }
    pub unsafe fn glean_set_log_pings(&self, value: u8) -> () {
        let sym = self
            .glean_set_log_pings
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(value)
    }
    pub unsafe fn glean_set_source_tags(&self, raw_tags: RawStringArray, tags_count: i32) -> u8 {
        let sym = self
            .glean_set_source_tags
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(raw_tags, tags_count)
    }
    pub unsafe fn glean_str_free(&self, s: *mut ::std::os::raw::c_char) -> () {
        let sym = self
            .glean_str_free
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(s)
    }
    pub unsafe fn glean_destroy_boolean_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_boolean_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_boolean_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
    ) -> u64 {
        let sym = self
            .glean_new_boolean_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
        )
    }
    pub unsafe fn glean_boolean_set(&self, metric_id: u64, value: u8) -> () {
        let sym = self
            .glean_boolean_set
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, value)
    }
    pub unsafe fn glean_boolean_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_boolean_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_boolean_test_get_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_boolean_test_get_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_counter_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_counter_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_counter_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
    ) -> u64 {
        let sym = self
            .glean_new_counter_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
        )
    }
    pub unsafe fn glean_counter_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_counter_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_counter_add(&self, metric_id: u64, amount: i32) -> () {
        let sym = self
            .glean_counter_add
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, amount)
    }
    pub unsafe fn glean_counter_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_counter_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_counter_test_get_value(&self, metric_id: u64, storage_name: FfiStr) -> i32 {
        let sym = self
            .glean_counter_test_get_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_custom_distribution_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_custom_distribution_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_custom_distribution_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        range_min: u64,
        range_max: u64,
        bucket_count: u64,
        histogram_type: i32,
    ) -> u64 {
        let sym = self
            .glean_new_custom_distribution_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            range_min,
            range_max,
            bucket_count,
            histogram_type,
        )
    }
    pub unsafe fn glean_custom_distribution_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_custom_distribution_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_custom_distribution_accumulate_samples(
        &self,
        metric_id: u64,
        raw_samples: RawInt64Array,
        num_samples: i32,
    ) -> () {
        let sym = self
            .glean_custom_distribution_accumulate_samples
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, raw_samples, num_samples)
    }
    pub unsafe fn glean_custom_distribution_test_has_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> u8 {
        let sym = self
            .glean_custom_distribution_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_custom_distribution_test_get_value_as_json_string(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_custom_distribution_test_get_value_as_json_string
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_datetime_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_datetime_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_datetime_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        time_unit: TimeUnit,
    ) -> u64 {
        let sym = self
            .glean_new_datetime_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            time_unit,
        )
    }
    pub unsafe fn glean_datetime_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_datetime_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_datetime_set(
        &self,
        metric_id: u64,
        year: i32,
        month: u32,
        day: u32,
        hour: u32,
        minute: u32,
        second: u32,
        nano: i64,
        offset_seconds: i32,
    ) -> () {
        let sym = self
            .glean_datetime_set
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            metric_id,
            year,
            month,
            day,
            hour,
            minute,
            second,
            nano,
            offset_seconds,
        )
    }
    pub unsafe fn glean_datetime_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_datetime_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_datetime_test_get_value_as_string(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_datetime_test_get_value_as_string
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_event_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_event_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_event_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_event_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_new_event_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        extra_keys: RawStringArray,
        extra_keys_len: i32,
    ) -> u64 {
        let sym = self
            .glean_new_event_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            extra_keys,
            extra_keys_len,
        )
    }
    pub unsafe fn glean_event_record(
        &self,
        metric_id: u64,
        timestamp: u64,
        extra_keys: RawIntArray,
        extra_values: RawStringArray,
        extra_len: i32,
    ) -> () {
        let sym = self
            .glean_event_record
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, timestamp, extra_keys, extra_values, extra_len)
    }
    pub unsafe fn glean_event_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_event_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_event_test_get_value_as_json_string(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_event_test_get_value_as_json_string
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_jwe_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_jwe_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_jwe_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
    ) -> u64 {
        let sym = self
            .glean_new_jwe_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
        )
    }
    pub unsafe fn glean_jwe_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_jwe_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_jwe_set_with_compact_representation(
        &self,
        metric_id: u64,
        value: FfiStr,
    ) -> () {
        let sym = self
            .glean_jwe_set_with_compact_representation
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, value)
    }
    pub unsafe fn glean_jwe_set(
        &self,
        metric_id: u64,
        header: FfiStr,
        key: FfiStr,
        init_vector: FfiStr,
        cipher_text: FfiStr,
        auth_tag: FfiStr,
    ) -> () {
        let sym = self
            .glean_jwe_set
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, header, key, init_vector, cipher_text, auth_tag)
    }
    pub unsafe fn glean_jwe_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_jwe_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_jwe_test_get_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_jwe_test_get_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_jwe_test_get_value_as_json_string(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_jwe_test_get_value_as_json_string
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_labeled_counter_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_labeled_counter_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_labeled_counter_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        labels: RawStringArray,
        label_count: i32,
    ) -> u64 {
        let sym = self
            .glean_new_labeled_counter_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            labels,
            label_count,
        )
    }
    pub unsafe fn glean_labeled_counter_metric_get(&self, handle: u64, label: FfiStr) -> u64 {
        let sym = self
            .glean_labeled_counter_metric_get
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(handle, label)
    }
    pub unsafe fn glean_labeled_counter_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_labeled_counter_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_destroy_labeled_boolean_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_labeled_boolean_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_labeled_boolean_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        labels: RawStringArray,
        label_count: i32,
    ) -> u64 {
        let sym = self
            .glean_new_labeled_boolean_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            labels,
            label_count,
        )
    }
    pub unsafe fn glean_labeled_boolean_metric_get(&self, handle: u64, label: FfiStr) -> u64 {
        let sym = self
            .glean_labeled_boolean_metric_get
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(handle, label)
    }
    pub unsafe fn glean_labeled_boolean_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_labeled_boolean_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_destroy_labeled_string_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_labeled_string_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_labeled_string_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        labels: RawStringArray,
        label_count: i32,
    ) -> u64 {
        let sym = self
            .glean_new_labeled_string_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            labels,
            label_count,
        )
    }
    pub unsafe fn glean_labeled_string_metric_get(&self, handle: u64, label: FfiStr) -> u64 {
        let sym = self
            .glean_labeled_string_metric_get
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(handle, label)
    }
    pub unsafe fn glean_labeled_string_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_labeled_string_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_destroy_memory_distribution_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_memory_distribution_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_memory_distribution_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        memory_unit: MemoryUnit,
    ) -> u64 {
        let sym = self
            .glean_new_memory_distribution_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            memory_unit,
        )
    }
    pub unsafe fn glean_memory_distribution_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_memory_distribution_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_memory_distribution_accumulate(&self, metric_id: u64, sample: u64) -> () {
        let sym = self
            .glean_memory_distribution_accumulate
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, sample)
    }
    pub unsafe fn glean_memory_distribution_accumulate_samples(
        &self,
        metric_id: u64,
        raw_samples: RawInt64Array,
        num_samples: i32,
    ) -> () {
        let sym = self
            .glean_memory_distribution_accumulate_samples
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, raw_samples, num_samples)
    }
    pub unsafe fn glean_memory_distribution_test_has_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> u8 {
        let sym = self
            .glean_memory_distribution_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_memory_distribution_test_get_value_as_json_string(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_memory_distribution_test_get_value_as_json_string
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_ping_type(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_ping_type
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_ping_type(
        &self,
        ping_name: FfiStr,
        include_client_id: u8,
        send_if_empty: u8,
        reason_codes: RawStringArray,
        reason_codes_len: i32,
    ) -> u64 {
        let sym = self
            .glean_new_ping_type
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            ping_name,
            include_client_id,
            send_if_empty,
            reason_codes,
            reason_codes_len,
        )
    }
    pub unsafe fn glean_test_has_ping_type(&self, ping_name: FfiStr) -> u8 {
        let sym = self
            .glean_test_has_ping_type
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(ping_name)
    }
    pub unsafe fn glean_register_ping_type(&self, ping_type_handle: u64) -> () {
        let sym = self
            .glean_register_ping_type
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(ping_type_handle)
    }
    pub unsafe fn glean_destroy_quantity_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_quantity_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_quantity_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
    ) -> u64 {
        let sym = self
            .glean_new_quantity_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
        )
    }
    pub unsafe fn glean_quantity_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_quantity_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_quantity_set(&self, metric_id: u64, value: i64) -> () {
        let sym = self
            .glean_quantity_set
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, value)
    }
    pub unsafe fn glean_quantity_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_quantity_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_quantity_test_get_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> i64 {
        let sym = self
            .glean_quantity_test_get_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_string_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_string_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_string_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
    ) -> u64 {
        let sym = self
            .glean_new_string_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
        )
    }
    pub unsafe fn glean_string_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_string_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_string_set(&self, metric_id: u64, value: FfiStr) -> () {
        let sym = self
            .glean_string_set
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, value)
    }
    pub unsafe fn glean_string_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_string_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_string_test_get_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_string_test_get_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_string_list_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_string_list_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_string_list_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
    ) -> u64 {
        let sym = self
            .glean_new_string_list_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
        )
    }
    pub unsafe fn glean_string_list_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_string_list_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_string_list_add(&self, metric_id: u64, value: FfiStr) -> () {
        let sym = self
            .glean_string_list_add
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, value)
    }
    pub unsafe fn glean_string_list_set(
        &self,
        metric_id: u64,
        values: RawStringArray,
        values_len: i32,
    ) -> () {
        let sym = self
            .glean_string_list_set
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, values, values_len)
    }
    pub unsafe fn glean_string_list_test_has_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> u8 {
        let sym = self
            .glean_string_list_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_string_list_test_get_value_as_json_string(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_string_list_test_get_value_as_json_string
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_timespan_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_timespan_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_timespan_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        time_unit: i32,
    ) -> u64 {
        let sym = self
            .glean_new_timespan_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            time_unit,
        )
    }
    pub unsafe fn glean_timespan_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_timespan_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_timespan_set_start(&self, metric_id: u64, start_time: u64) -> () {
        let sym = self
            .glean_timespan_set_start
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, start_time)
    }
    pub unsafe fn glean_timespan_set_stop(&self, metric_id: u64, stop_time: u64) -> () {
        let sym = self
            .glean_timespan_set_stop
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, stop_time)
    }
    pub unsafe fn glean_timespan_cancel(&self, metric_id: u64) -> () {
        let sym = self
            .glean_timespan_cancel
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id)
    }
    pub unsafe fn glean_timespan_set_raw_nanos(&self, metric_id: u64, elapsed_nanos: u64) -> () {
        let sym = self
            .glean_timespan_set_raw_nanos
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, elapsed_nanos)
    }
    pub unsafe fn glean_timespan_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_timespan_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_timespan_test_get_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> u64 {
        let sym = self
            .glean_timespan_test_get_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_timing_distribution_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_timing_distribution_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_timing_distribution_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
        time_unit: TimeUnit,
    ) -> u64 {
        let sym = self
            .glean_new_timing_distribution_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
            time_unit,
        )
    }
    pub unsafe fn glean_timing_distribution_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_timing_distribution_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_timing_distribution_set_start(
        &self,
        metric_id: u64,
        start_time: u64,
    ) -> TimerId {
        let sym = self
            .glean_timing_distribution_set_start
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, start_time)
    }
    pub unsafe fn glean_timing_distribution_set_stop_and_accumulate(
        &self,
        metric_id: u64,
        timer_id: TimerId,
        stop_time: u64,
    ) -> () {
        let sym = self
            .glean_timing_distribution_set_stop_and_accumulate
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, timer_id, stop_time)
    }
    pub unsafe fn glean_timing_distribution_cancel(&self, metric_id: u64, timer_id: TimerId) -> () {
        let sym = self
            .glean_timing_distribution_cancel
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, timer_id)
    }
    pub unsafe fn glean_timing_distribution_accumulate_samples(
        &self,
        metric_id: u64,
        raw_samples: RawInt64Array,
        num_samples: i32,
    ) -> () {
        let sym = self
            .glean_timing_distribution_accumulate_samples
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, raw_samples, num_samples)
    }
    pub unsafe fn glean_timing_distribution_test_has_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> u8 {
        let sym = self
            .glean_timing_distribution_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_timing_distribution_test_get_value_as_json_string(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_timing_distribution_test_get_value_as_json_string
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_destroy_uuid_metric(&self, v: u64) -> () {
        let sym = self
            .glean_destroy_uuid_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(v)
    }
    pub unsafe fn glean_new_uuid_metric(
        &self,
        category: FfiStr,
        name: FfiStr,
        send_in_pings: RawStringArray,
        send_in_pings_len: i32,
        lifetime: Lifetime,
        disabled: u8,
    ) -> u64 {
        let sym = self
            .glean_new_uuid_metric
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            category,
            name,
            send_in_pings,
            send_in_pings_len,
            lifetime,
            disabled,
        )
    }
    pub unsafe fn glean_uuid_test_get_num_recorded_errors(
        &self,
        metric_id: u64,
        error_type: i32,
        storage_name: FfiStr,
    ) -> i32 {
        let sym = self
            .glean_uuid_test_get_num_recorded_errors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, error_type, storage_name)
    }
    pub unsafe fn glean_uuid_set(&self, metric_id: u64, value: FfiStr) -> () {
        let sym = self
            .glean_uuid_set
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, value)
    }
    pub unsafe fn glean_uuid_test_has_value(&self, metric_id: u64, storage_name: FfiStr) -> u8 {
        let sym = self
            .glean_uuid_test_has_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
    pub unsafe fn glean_uuid_test_get_value(
        &self,
        metric_id: u64,
        storage_name: FfiStr,
    ) -> *mut ::std::os::raw::c_char {
        let sym = self
            .glean_uuid_test_get_value
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(metric_id, storage_name)
    }
}
