// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use std::marker::PhantomData;

use inherent::inherent;

use glean_core::ErrorType;

/// Sealed traits protect against downstream implementations.
///
/// We wrap it in a private module that is inaccessible outside of this module.
mod private {
    use crate::{private::CounterMetric, private::StringMetric, CommonMetricData};
    use std::ffi::CString;

    /// The sealed labeled trait.
    ///
    /// This also allows us to hide methods, that are only used internally
    /// and should not be visible to users of the object implementing the
    /// `Labeled<T>` trait.
    pub trait Sealed {
        /// Create a new `glean_core` metric from the metadata.
        fn new_labeled(meta: crate::CommonMetricData, labels: Option<Vec<String>>) -> u64;

        /// Get a new labeled metric for the given `label`.
        fn get(metric_id: u64, label: &str) -> Self;
    }

    // `LabeledMetric<StringListMetric>` is possible.
    //
    // See [Labeled Counters](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html).
    impl Sealed for StringMetric {
        fn new_labeled(meta: CommonMetricData, labels: Option<Vec<String>>) -> u64 {
            let (label_count, _labels, label_ptr) = match labels {
                Some(labels) => {
                    let labels: Vec<::std::ffi::CString> = labels
                        .into_iter()
                        .map(|s| ::std::ffi::CString::new(s).unwrap())
                        .collect();
                    let labels_ptr: Vec<*const i8> = labels.iter().map(|s| s.as_ptr()).collect();
                    (labels.len(), labels, labels_ptr)
                }
                None => (0, vec![], vec![]),
            };

            new_metric!(
                glean_new_labeled_string_metric,
                meta,
                label_ptr.as_ptr(),
                label_count as i32
            )
        }

        fn get(metric_id: u64, label: &str) -> Self {
            let id = crate::sys::with_glean(|glean| unsafe {
                let label = CString::new(label).unwrap();
                glean.glean_labeled_string_metric_get(metric_id, label.as_ptr())
            }).unwrap_or(0);

            StringMetric(id)
        }
    }

    // `LabeledMetric<CounterMetric>` is possible.
    //
    // See [Labeled Counters](https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html).
    impl Sealed for CounterMetric {
        fn new_labeled(meta: CommonMetricData, labels: Option<Vec<String>>) -> u64 {
            let (label_count, _labels, label_ptr) = match labels {
                Some(labels) => {
                    let labels: Vec<::std::ffi::CString> = labels
                        .into_iter()
                        .map(|s| ::std::ffi::CString::new(s).unwrap())
                        .collect();
                    let labels_ptr: Vec<*const i8> = labels.iter().map(|s| s.as_ptr()).collect();
                    (labels.len(), labels, labels_ptr)
                }
                None => (0, vec![], vec![]),
            };

            new_metric!(
                glean_new_labeled_counter_metric,
                meta,
                label_ptr.as_ptr(),
                label_count as i32
            )
        }

        fn get(metric_id: u64, label: &str) -> Self {
            let id = crate::sys::with_glean(|glean| unsafe {
                let label = CString::new(label).unwrap();
                glean.glean_labeled_counter_metric_get(metric_id, label.as_ptr())
            }).unwrap_or(0);

            CounterMetric(id)
        }
    }
}

/// Marker trait for metrics that can be nested inside a labeled metric.
///
/// This trait is sealed and cannot be implemented for types outside this crate.
pub trait AllowLabeled: private::Sealed {}

// Implement the trait for everything we marked as allowed.
impl<T> AllowLabeled for T where T: private::Sealed {}

// We need to wrap the glean-core type: otherwise if we try to implement
// the trait for the metric in `glean_core::metrics` we hit error[E0117]:
// only traits defined in the current crate can be implemented for arbitrary
// types.

/// This implements the specific facing API for recording labeled metrics.
///
/// Instances of this type are automatically generated by the parser
/// at build time, allowing developers to record values that were previously
/// registered in the metrics.yaml file.
/// Unlike most metric types, [`LabeledMetric`] does not have its own corresponding
/// storage, but records metrics for the underlying metric type `T` in the storage
/// for that type.
#[derive(Clone)]
pub struct LabeledMetric<T: AllowLabeled> {
    pub(crate) id: u64,
    inner: PhantomData<T>,
}

impl<T> LabeledMetric<T>
where
    T: AllowLabeled,
{
    /// The public constructor used by automatically generated metrics.
    pub fn new(meta: glean_core::CommonMetricData, labels: Option<Vec<String>>) -> Self {
        let inner = T::new_labeled(meta, labels);
        Self {
            id: inner,
            inner: PhantomData,
        }
    }
}

#[inherent(pub)]
impl<T> glean_core::traits::Labeled<T> for LabeledMetric<T>
where
    T: AllowLabeled + Clone,
{
    fn get(&self, label: &str) -> T {
        T::get(self.id, label)
    }

    fn test_get_num_recorded_errors<'a, S: Into<Option<&'a str>>>(
        &self,
        _error: ErrorType,
        _ping_name: S,
    ) -> i32 {
        todo!()
    }
}
